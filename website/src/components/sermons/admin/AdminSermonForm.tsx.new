"use client";

import { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { useForm, Controller } from 'react-hook-form';
import {
  fetchSermonById,
  fetchSermonSeries,
  fetchTags,
  saveSermon,
  uploadSermonMedia,
  UploadResult,
  UploadProgress,
  Sermon,
  SermonSeries
} from '@/services/sermonService';
import {
  validateFile,
  FileValidationResult,
  AUDIO_FILE_CONFIG,
  VIDEO_FILE_CONFIG,
  IMAGE_FILE_CONFIG
} from '@/utils/fileValidation';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { posthog } from '@/services/posthog';

interface AdminSermonFormProps {
  sermonId?: string;
  onSave?: (sermonData: Sermon) => Promise<void>;
  isSaving?: boolean;
}

interface FileUploadState {
  file: File | null;
  isUploading: boolean;
  progress: number;
  error: string | null;
}

interface FormState {
  audio: FileUploadState;
  video: FileUploadState;
  thumbnail: FileUploadState;
}

type MediaType = 'audio' | 'video' | 'thumbnail';

export default function AdminSermonForm({ sermonId, onSave, isSaving = false }: AdminSermonFormProps) {
  const router = useRouter();
  const queryClient = useQueryClient();
  const isEditMode = !!sermonId;

  // Media upload state management
  const [formState, setFormState] = useState<FormState>({
    audio: { file: null, isUploading: false, progress: 0, error: null },
    video: { file: null, isUploading: false, progress: 0, error: null },
    thumbnail: { file: null, isUploading: false, progress: 0, error: null }
  });

  // Form setup with react-hook-form
  const {
    register,
    handleSubmit,
    control,
    reset,
    setValue,
    watch,
    formState: { errors: formErrors, isSubmitting }
  } = useForm<Sermon>({
    defaultValues: {
      title: '',
      description: '',
      scripture_reference: '',
      speaker_name: '',
      sermon_date: new Date().toISOString().split('T')[0],
      tags: [],
      series_id: undefined,
      is_featured: false,
      is_published: true,
    }
  });

  // Get existing sermon data if in edit mode
  const { data: existingSermon, isLoading: isLoadingSermon } = useQuery({
    queryKey: ['sermon', sermonId],
    queryFn: () => fetchSermonById(sermonId!),
    enabled: isEditMode,
  });

  // Get series data for dropdown
  const { data: seriesList = [] } = useQuery({
    queryKey: ['sermonSeries'],
    queryFn: fetchSermonSeries,
  });

  // Get existing tags for suggestions
  const { data: existingTags = [] } = useQuery({
    queryKey: ['sermonTags'],
    queryFn: fetchTags,
  });

  // Save sermon mutation
  const saveMutation = useMutation({
    mutationFn: saveSermon,
    onSuccess: (savedSermon) => {
      queryClient.invalidateQueries({ queryKey: ['admin-sermons'] });
      
      // Track success in analytics
      posthog.capture(isEditMode ? 'sermon_updated' : 'sermon_created', {
        sermon_id: savedSermon.id,
        sermon_title: savedSermon.title,
        has_audio: !!savedSermon.audio_url || !!formState.audio.file,
        has_video: !!savedSermon.video_url || !!formState.video.file,
        has_thumbnail: !!savedSermon.thumbnail_url || !!formState.thumbnail.file,
        has_transcript: !!savedSermon.transcript,
        tags: savedSermon.tags?.length || 0,
        is_featured: savedSermon.is_featured,
        is_published: savedSermon.is_published
      });

      if (!isEditMode) {
        router.push(`/admin/sermons/edit/${savedSermon.id}`);
      }
    },
  });

  // Handle file changes
  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>, type: MediaType) => {
    if (e.target.files && e.target.files[0]) {
      const file = e.target.files[0];
      
      // Get appropriate validation config
      const config = type === 'audio' 
        ? AUDIO_FILE_CONFIG 
        : type === 'video' 
          ? VIDEO_FILE_CONFIG 
          : IMAGE_FILE_CONFIG;

      // Validate file
      const validationResult = validateFile(file, config);

      if (!validationResult.isValid) {
        setFormState(prev => ({
          ...prev,
          [type]: {
            ...prev[type],
            error: validationResult.error || `Invalid ${type} file`,
            file: null
          }
        }));
        e.target.value = '';
        return;
      }

      // Update form state with new file
      setFormState(prev => ({
        ...prev,
        [type]: {
          file,
          isUploading: false,
          progress: 0,
          error: null
        }
      }));
    }
  };

  // Handle file upload
  const handleUploadFile = async (type: MediaType) => {
    const state = formState[type];
    if (!state.file || !existingSermon?.id) return null;
    
    try {
      setFormState(prev => ({
        ...prev,
        [type]: { ...prev[type], isUploading: true, error: null }
      }));

      const result = await uploadSermonMedia(
        state.file,
        existingSermon.id,
        type,
        undefined,
        (progress) => {
          setFormState(prev => ({
            ...prev,
            [type]: { ...prev[type], progress: progress.progress }
          }));
        }
      );

      if (result.error) {
        setFormState(prev => ({
          ...prev,
          [type]: { ...prev[type], error: result.error, isUploading: false }
        }));
        return null;
      }

      // Update form data with new URL
      setValue(`${type}_url`, result.url);

      setFormState(prev => ({
        ...prev,
        [type]: { ...prev[type], isUploading: false, progress: 0 }
      }));

      return result.url;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Upload failed';
      setFormState(prev => ({
        ...prev,
        [type]: { ...prev[type], error: errorMessage, isUploading: false }
      }));
      return null;
    }
  };

  // Form submission handler
  const onSubmit = async (data: Sermon) => {
    try {
      const savedSermon = await saveMutation.mutateAsync(data);

      // Upload files if we have them
      if (savedSermon.id) {
        if (formState.audio.file) await handleUploadFile('audio');
        if (formState.video.file) await handleUploadFile('video');
        if (formState.thumbnail.file) await handleUploadFile('thumbnail');
      }

      if (onSave) {
        await onSave(savedSermon);
      }
    } catch (error) {
      console.error('Error saving sermon:', error);
      
      // Track error in analytics
      posthog.capture('sermon_save_error', {
        error_message: error instanceof Error ? error.message : 'Unknown error',
        is_edit_mode: isEditMode
      });
    }
  };

  // Set form values when existing sermon data is loaded
  useEffect(() => {
    if (existingSermon) {
      reset(existingSermon);
    }
  }, [existingSermon, reset]);

  // Continue with the rest of your component rendering...
  // This is where you'll add your JSX for the form UI
  return (
    <form onSubmit={handleSubmit(onSubmit)} className="space-y-6">
      {/* Form fields will go here */}
    </form>
  );
}
